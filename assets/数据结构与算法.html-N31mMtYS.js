import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,o as a,i}from"./app-DfRKKd8F.js";const t={},n=i('<h2 id="_1-数据结构" tabindex="-1"><a class="header-anchor" href="#_1-数据结构"><span>1.数据结构</span></a></h2><h3 id="_1-1数据结构是什么" tabindex="-1"><a class="header-anchor" href="#_1-1数据结构是什么"><span>1.1数据结构是什么</span></a></h3><p>数据结构（data structure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法，它具有以下设计目标。</p><ul><li><p>空间占用尽量少，以节省计算机内存。</p></li><li><p>数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。</p></li><li><p>提供简洁的数据表示和逻辑信息，以便算法高效运行。 数据结构设计是一个充满权衡的过程。如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。</p></li><li><p>链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。</p></li><li><p>图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。</p></li></ul><h3 id="_1-2数据结构的分类" tabindex="-1"><a class="header-anchor" href="#_1-2数据结构的分类"><span>1.2数据结构的分类</span></a></h3><p>1️⃣ 逻辑结构的分类</p><ul><li>线性结构：数组，链表，栈，队列，哈希表</li><li>非线性结构：树，堆，图 <img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_logic_structure.png" alt="" loading="lazy"></li></ul><p>2️⃣ 物理结构的分类</p><ul><li>顺序结构：划分连续内存空间（元素顺序访问）</li><li>链式结构：使用分散内存空间（内存寻址访问） <img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_phisical_structure.png" alt="" loading="lazy"></li></ul><h3 id="_1-3数字编码格式" tabindex="-1"><a class="header-anchor" href="#_1-3数字编码格式"><span>1.3数字编码格式</span></a></h3><ul><li>原码：数字的二进制表示的最高位视为符号位，其中 表示<code>0</code>正数，<code>1</code>表示负数，其余位表示数字的值。</li><li>补码：正数的补码与其原码相同，负数的补码是在其反码的基础上加<code>1</code>。</li><li>反码：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。 <img src="https://www.hello-algo.com/chapter_data_structure/number_encoding.assets/1s_2s_complement.png" alt="" loading="lazy"></li><li>浮点数编码:<br> IEEE 754 是一种广泛使用的浮点数编码格式标准，它定义了浮点数的编码格式、运算规则和异常处理机制。IEEE 754 浮点数编码格式包括以下几种：</li></ul><ol><li>单精度浮点数（Single Precision）<br> 单精度浮点数使用 32 位二进制代码来表示实数，包括：</li></ol><ul><li>符号位（Sign bit）：1 位，表示数的符号（正或负）</li><li>指数位（Exponent bits）：8 位，表示指数的值</li><li>尾数位（Mantissa bits）：23 位，表示尾数的值</li></ul><ol start="2"><li>双精度浮点数（Double Precision）<br> 双精度浮点数使用 64 位二进制代码来表示实数，包括：</li></ol><ul><li>符号位（Sign bit）：1 位，表示数的符号（正或负）</li><li>指数位（Exponent bits）：11 位，表示指数的值</li><li>尾数位（Mantissa bits）：52 位，表示尾数的值</li></ul><ol start="3"><li>扩展精度浮点数（Extended Precision）<br> 扩展精度浮点数使用 80 位二进制代码来表示实数，包括：</li></ol><ul><li>符号位（Sign bit）：1 位，表示数的符号（正或负）</li><li>指数位（Exponent bits）：15 位，表示指数的值</li><li>尾数位（Mantissa bits）：64 位，表示尾数的值</li></ul><h2 id="_2-算法" tabindex="-1"><a class="header-anchor" href="#_2-算法"><span>2.算法</span></a></h2><h3 id="_2-1算法是什么" tabindex="-1"><a class="header-anchor" href="#_2-1算法是什么"><span>2.1算法是什么</span></a></h3><p>算法是解决特定问题的一系列步骤或规则。它可以被看作是一个清晰的指令集合，用于完成特定的任务或计算。算法通常涉及以下几个方面：</p><ol><li><strong>输入</strong>：算法接收某些数据或参数作为输入。</li><li><strong>处理</strong>：算法通过一系列步骤对输入数据进行处理。</li><li><strong>输出</strong>：算法产生结果或输出，完成任务。</li></ol><p>算法可以用来解决各种问题，如排序、搜索、计算、图像处理等。它们可以用不同的编程语言实现，并且在计算机科学中，算法是编程和数据处理的核心。</p><h3 id="_2-2算法效率的评估" tabindex="-1"><a class="header-anchor" href="#_2-2算法效率的评估"><span>2.2算法效率的评估</span></a></h3><p>在算法设计中，我们先后追求以下两个层面的目标。</p><ol><li>**找到问题解法：**算法需要在规定的输入范围内可靠地求得问题的正确解。</li><li>**寻求最优解法：**同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。 也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，它包括以下两个维度。</li></ol><ul><li>时间效率：算法运行时间的长短。</li><li>空间效率：算法占用内存空间的大小。 简而言之，我们的目标是设计“既快又省”的数据结构与算法。而有效地评估算法效率至关重要，因为只有这样，我们才能将各种算法进行对比，进而指导算法设计与优化过程。</li></ul><p>效率评估方法主要分为两种：<code>实际测试</code>、<code>理论估算</code>。</p><h3 id="_2-3算法中的迭代与递归" tabindex="-1"><a class="header-anchor" href="#_2-3算法中的迭代与递归"><span>2.3算法中的迭代与递归</span></a></h3><p>在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。因此，在介绍时间复杂度和空间复杂度之前，我们先来了解如何在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。</p><h4 id="_2-3-1迭代" tabindex="-1"><a class="header-anchor" href="#_2-3-1迭代"><span>2.3.1迭代</span></a></h4><p>迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。</p><ul><li>for循环</li><li>while循环</li></ul><h4 id="_2-3-2递归" tabindex="-1"><a class="header-anchor" href="#_2-3-2递归"><span>2.3.2递归</span></a></h4><p>递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p><ol><li><p>递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</p></li><li><p>归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。 而从实现的角度看，递归代码主要包含三个要素。</p></li><li><p>终止条件：用于决定什么时候由“递”转“归”。</p></li><li><p>递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。</p></li><li><p>返回结果：对应“归”，将当前递归层级的结果返回至上一层。</p></li></ol><h4 id="_2-3-3选择迭代还是递归" tabindex="-1"><a class="header-anchor" href="#_2-3-3选择迭代还是递归"><span>2.3.3选择迭代还是递归</span></a></h4><ul><li>迭代：适用于大多数简单的循环任务，通常更高效，且没有栈溢出风险。</li><li>递归：适用于问题可以自然地分解为更小的相似问题的情况，如树结构遍历、图遍历、数学归纳法问题等。</li></ul><h3 id="_2-4时间复杂度" tabindex="-1"><a class="header-anchor" href="#_2-4时间复杂度"><span>2.4时间复杂度</span></a></h3><p>算法的时间复杂度是衡量算法执行所需时间的指标，它反映了算法在处理输入数据时，随着数据规模的增大，执行时间的增长速度。时间复杂度通常用大O符号表示（O-notation），常见的时间复杂度有：</p><ol><li><p><strong>O(1)</strong>：常数时间复杂度，不论输入数据规模多大，算法的执行时间都是固定的。例如，访问数组的某个元素。</p></li><li><p><strong>O(log n)</strong>：对数时间复杂度，通常出现在二分查找等算法中，数据规模增加，时间复杂度的增长速度较慢。例如，二分查找在有序数组中的查找。</p></li><li><p><strong>O(n)</strong>：线性时间复杂度，算法的执行时间与输入数据规模成正比。例如，遍历一个数组。</p></li><li><p><strong>O(n log n)</strong>：线性对数时间复杂度，常见于许多高效的排序算法，如快速排序和归并排序。</p></li><li><p><strong>O(n²)</strong>：平方时间复杂度，常见于一些简单的排序算法，如冒泡排序和选择排序，以及双层循环的情况。</p></li><li><p><strong>O(2^n)</strong>：指数时间复杂度，通常出现在一些递归算法中，例如求解斐波那契数列的朴素递归解法。</p></li><li><p><strong>O(n!)</strong>：阶乘时间复杂度，通常出现在一些组合问题中，例如旅行商问题的暴力解法。</p></li></ol><p>理解时间复杂度有助于评估算法在处理大规模数据时的表现，并选择最适合的算法和优化策略。</p><h3 id="_2-5空间复杂度" tabindex="-1"><a class="header-anchor" href="#_2-5空间复杂度"><span>2.5空间复杂度</span></a></h3><p>空间复杂度是衡量算法在执行过程中所占用的存储空间的指标。它反映了随着输入数据规模的增大，算法所需存储空间的增长速度。空间复杂度同样使用大O符号表示，常见的空间复杂度包括：</p><ol><li><p><strong>O(1)</strong>：常数空间复杂度，算法所需的空间不随输入数据规模的增大而增加。例如，简单的变量赋值操作或对数组元素的直接访问。</p></li><li><p><strong>O(n)</strong>：线性空间复杂度，算法所需的空间与输入数据规模成正比。例如，将输入数据复制到另一个数组或列表中。</p></li><li><p><strong>O(log n)</strong>：对数空间复杂度，通常出现在递归算法中，递归深度为log n时，所需的额外空间也是log n。</p></li><li><p><strong>O(n log n)</strong>：线性对数空间复杂度，通常出现在一些需要额外临时存储的递归或分治算法中。</p></li><li><p><strong>O(n²)</strong>：平方空间复杂度，算法所需的空间与输入数据规模的平方成正比。例如，在矩阵运算中，需要存储一个n x n的矩阵。</p></li></ol><h4 id="空间复杂度的考虑因素" tabindex="-1"><a class="header-anchor" href="#空间复杂度的考虑因素"><span>空间复杂度的考虑因素</span></a></h4><ul><li><strong>辅助空间（Auxiliary Space）</strong>：除了输入数据之外，算法执行过程中所需的额外空间。例如，排序算法中的临时存储空间。</li><li><strong>输入数据空间</strong>：算法处理输入数据时所占用的空间。</li></ul><h4 id="典型例子" tabindex="-1"><a class="header-anchor" href="#典型例子"><span>典型例子</span></a></h4><ul><li><strong>递归调用</strong>：递归算法的空间复杂度通常与递归深度有关，因为每次递归调用都会占用栈空间。</li><li><strong>动态规划</strong>：某些动态规划算法需要使用额外的数组来存储中间结果，其空间复杂度通常为O(n)或O(n²)。</li></ul><p>理解空间复杂度有助于优化算法，尤其在处理大数据或内存受限的环境中，空间复杂度是选择合适算法的重要考虑因素之一。</p><h2 id="线性表" tabindex="-1"><a class="header-anchor" href="#线性表"><span>线性表</span></a></h2><h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h3><h3 id="链表" tabindex="-1"><a class="header-anchor" href="#链表"><span>链表</span></a></h3><h2 id="栈和队列" tabindex="-1"><a class="header-anchor" href="#栈和队列"><span>栈和队列</span></a></h2><h2 id="哈希表" tabindex="-1"><a class="header-anchor" href="#哈希表"><span>哈希表</span></a></h2><h2 id="树" tabindex="-1"><a class="header-anchor" href="#树"><span>树</span></a></h2><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h2><h2 id="图" tabindex="-1"><a class="header-anchor" href="#图"><span>图</span></a></h2><h2 id="搜索" tabindex="-1"><a class="header-anchor" href="#搜索"><span>搜索</span></a></h2><h2 id="排序" tabindex="-1"><a class="header-anchor" href="#排序"><span>排序</span></a></h2><h2 id="递归" tabindex="-1"><a class="header-anchor" href="#递归"><span>递归</span></a></h2><h2 id="分治" tabindex="-1"><a class="header-anchor" href="#分治"><span>分治</span></a></h2><h2 id="回溯" tabindex="-1"><a class="header-anchor" href="#回溯"><span>回溯</span></a></h2><h2 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划"><span>动态规划</span></a></h2><h2 id="贪心" tabindex="-1"><a class="header-anchor" href="#贪心"><span>贪心</span></a></h2>',64),s=[n];function r(o,h){return a(),l("div",null,s)}const d=e(t,[["render",r],["__file","数据结构与算法.html.vue"]]),g=JSON.parse('{"path":"/develop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html","title":"数据结构与算法","lang":"zh-CN","frontmatter":{"cover":"/assets/images/cover3.jpg","title":"数据结构与算法","date":"2024-08-06T00:00:00.000Z","icon":"pen-to-square","author":null,"isOriginal":true,"category":["数据结构"],"tag":["数据结构","算法","Java实现"],"sticky":1,"star":1,"article":true,"timeline":true,"license":null,"description":"1.数据结构 1.1数据结构是什么 数据结构（data structure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法，它具有以下设计目标。 空间占用尽量少，以节省计算机内存。 数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。 提供简洁的数据表示和逻辑信息，以便算法高效运行。 数据结构设计是一个充满权衡的过程。如果想在某方面...","head":[["meta",{"property":"og:url","content":"https://jianghu105.github.io/develop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Jianghu"}],["meta",{"property":"og:title","content":"数据结构与算法"}],["meta",{"property":"og:description","content":"1.数据结构 1.1数据结构是什么 数据结构（data structure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法，它具有以下设计目标。 空间占用尽量少，以节省计算机内存。 数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。 提供简洁的数据表示和逻辑信息，以便算法高效运行。 数据结构设计是一个充满权衡的过程。如果想在某方面..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jianghu105.github.io/assets/images/cover3.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://jianghu105.github.io/assets/images/cover3.jpg"}],["meta",{"name":"twitter:image:alt","content":"数据结构与算法"}],["meta",{"property":"article:author","content":"Jianghu"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:tag","content":"Java实现"}],["meta",{"property":"article:published_time","content":"2024-08-06T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构与算法\\",\\"image\\":[\\"https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_logic_structure.png\\",\\"https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_phisical_structure.png\\",\\"https://www.hello-algo.com/chapter_data_structure/number_encoding.assets/1s_2s_complement.png\\"],\\"datePublished\\":\\"2024-08-06T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jianghu\\",\\"url\\":\\"https://jianghu105.github.io/intro.html\\"}]}"]]},"headers":[{"level":2,"title":"1.数据结构","slug":"_1-数据结构","link":"#_1-数据结构","children":[{"level":3,"title":"1.1数据结构是什么","slug":"_1-1数据结构是什么","link":"#_1-1数据结构是什么","children":[]},{"level":3,"title":"1.2数据结构的分类","slug":"_1-2数据结构的分类","link":"#_1-2数据结构的分类","children":[]},{"level":3,"title":"1.3数字编码格式","slug":"_1-3数字编码格式","link":"#_1-3数字编码格式","children":[]}]},{"level":2,"title":"2.算法","slug":"_2-算法","link":"#_2-算法","children":[{"level":3,"title":"2.1算法是什么","slug":"_2-1算法是什么","link":"#_2-1算法是什么","children":[]},{"level":3,"title":"2.2算法效率的评估","slug":"_2-2算法效率的评估","link":"#_2-2算法效率的评估","children":[]},{"level":3,"title":"2.3算法中的迭代与递归","slug":"_2-3算法中的迭代与递归","link":"#_2-3算法中的迭代与递归","children":[]},{"level":3,"title":"2.4时间复杂度","slug":"_2-4时间复杂度","link":"#_2-4时间复杂度","children":[]},{"level":3,"title":"2.5空间复杂度","slug":"_2-5空间复杂度","link":"#_2-5空间复杂度","children":[]}]},{"level":2,"title":"线性表","slug":"线性表","link":"#线性表","children":[{"level":3,"title":"数组","slug":"数组","link":"#数组","children":[]},{"level":3,"title":"链表","slug":"链表","link":"#链表","children":[]}]},{"level":2,"title":"栈和队列","slug":"栈和队列","link":"#栈和队列","children":[]},{"level":2,"title":"哈希表","slug":"哈希表","link":"#哈希表","children":[]},{"level":2,"title":"树","slug":"树","link":"#树","children":[]},{"level":2,"title":"堆","slug":"堆","link":"#堆","children":[]},{"level":2,"title":"图","slug":"图","link":"#图","children":[]},{"level":2,"title":"搜索","slug":"搜索","link":"#搜索","children":[]},{"level":2,"title":"排序","slug":"排序","link":"#排序","children":[]},{"level":2,"title":"递归","slug":"递归","link":"#递归","children":[]},{"level":2,"title":"分治","slug":"分治","link":"#分治","children":[]},{"level":2,"title":"回溯","slug":"回溯","link":"#回溯","children":[]},{"level":2,"title":"动态规划","slug":"动态规划","link":"#动态规划","children":[]},{"level":2,"title":"贪心","slug":"贪心","link":"#贪心","children":[]}],"git":{},"readingTime":{"minutes":8.77,"words":2632},"filePathRelative":"develop/计算机基础/数据结构与算法/数据结构与算法.md","localizedDate":"2024年8月6日","excerpt":"","autoDesc":true}');export{d as comp,g as data};
